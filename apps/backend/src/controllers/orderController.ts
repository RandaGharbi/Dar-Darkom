import { Request, Response } from "express";
import Order from "../models/Order";
import Cart, { ICart } from "../models/Basket";
import { IProduct } from "../types";
import mongoose from "mongoose";
import { sendNotification, sendOrderNotification, sendAdminNotification } from "../index";
import { addDynamicNotification } from "./notificationController";
import User from "../models/User";
import { smsService } from "../services/smsService"; // üÜï Import du service SMS

export const createOrder = async (req: Request, res: Response) => {
  const userId = req.body.userId;
  console.log("POST /orders/create re√ßu", req.body);
  if (!userId) {
    console.log("userId manquant dans la requ√™te");
    return res.status(400).json({ message: "userId requis" });
  }
  try {
    const userObjectId = new mongoose.Types.ObjectId(userId);
    console.log("Recherche du panier pour userId:", userId, "->", userObjectId);
    // R√©cup√®re le panier de l'utilisateur
    const cart = (await Cart.findOne({ userId: userObjectId }).populate(
      "items.productId"
    )) as ICart | null;
    console.log("Panier trouv√©:", cart);
    if (!cart || !cart.items.length) {
      console.log("Panier vide pour userId:", userId, cart);
      return res.status(400).json({ message: "Panier vide" });
    }
    // Pr√©pare les items de la commande avec tous les d√©tails produit
    const items = cart.items.map((item) => {
      const product = item.productId as unknown as IProduct;
      console.log("Image du produit:", product.image);
      return {
        name: product.name,
        qty: item.quantity,
        image: product.image || '',
        price: product.price,
      };
    });
    const subtotal = items.reduce((sum, p) => sum + (p.price || 0) * (p.qty || 1), 0);
    const shipping = 5;
    const tax = 0.1 * subtotal;
    const total = subtotal + shipping + tax;
    console.log("Items pr√©par√©s pour la commande:", items);
    console.log('shippingAddress re√ßu:', req.body.shippingAddress);
    // Cr√©e la commande
    const order = await Order.create({
      userId: userObjectId,
      products: items,
      subtotal,
      shipping,
      tax,
      total,
      shippingAddress: {
        street: req.body.shippingAddress?.street,
        city: req.body.shippingAddress?.city,
        postalCode: req.body.shippingAddress?.postalCode,
        country: req.body.shippingAddress?.country,
      },
      isOrdered: true,
    });
    console.log("Nouvelle commande cr√©√©e:", order);
    
    // Trouver l'administrateur pour envoyer la notification
    try {
      const admin = await User.findOne({ role: 'admin' });
      if (admin) {
        // R√©cup√©rer les informations de l'utilisateur qui a pass√© la commande
        const user = await User.findById(userId);
        const userName = user ? user.name : 'Utilisateur';
        
        // Envoyer une notification √† l'administrateur
        const notification = {
          _id: `order-${order._id}`,
          userId: (admin._id as string).toString(),
          title: "Nouvelle commande re√ßue",
          message: `Commande #${(order._id as string).toString().slice(-8)} de ${userName} - Total: ${total.toFixed(2)}‚Ç¨`,
          createdAt: new Date().toISOString(),
          isRead: false,
          type: 'order' as const,
          metadata: {
            orderId: (order._id as string).toString(),
            amount: total,
            customerName: userName
          }
        };
        
        // Envoyer notification WebSocket √† l'admin
        sendAdminNotification({
          title: notification.title,
          message: notification.message,
          type: 'new_order',
          metadata: {
            orderId: notification.metadata.orderId,
            amount: notification.metadata.amount,
            customerName: notification.metadata.customerName
          }
        });
        
        // Envoyer aussi la notification persistante
        addDynamicNotification(notification);
        console.log("‚úÖ Notification envoy√©e √† l'administrateur");
      } else {
        console.log("‚ö†Ô∏è Aucun administrateur trouv√© pour les notifications");
      }
    } catch (notificationError) {
      console.error("‚ùå Erreur lors de l'envoi de la notification:", notificationError);
    }

    // üÜï Envoyer SMS de confirmation de commande au client
    try {
      const user = await User.findById(userId);
      if (user && user.phoneNumber && smsService.validatePhoneNumber(user.phoneNumber)) {
        console.log('üì± [SMS] Envoi de confirmation de commande √†:', user.phoneNumber);
        
        const formattedPhone = smsService.formatPhoneNumber(user.phoneNumber);
        const smsResult = await smsService.sendOrderNotificationSMS({
          to: formattedPhone,
          userName: user.name,
          orderId: (order._id as string).toString().slice(-8),
          orderTotal: total,
          orderStatus: 'PENDING',
          companyName: 'Dar-Darkom'
        });

        if (smsResult.success) {
          console.log('‚úÖ [SMS] SMS de confirmation envoy√© avec succ√®s');
        } else {
          console.log('‚ö†Ô∏è [SMS] √âchec d\'envoi du SMS:', smsResult.error);
        }
      } else {
        console.log('‚ö†Ô∏è [SMS] Num√©ro de t√©l√©phone invalide ou manquant pour:', user?.email);
      }
    } catch (smsError) {
      console.error('‚ùå [SMS] Erreur lors de l\'envoi du SMS de confirmation:', smsError);
      // On continue m√™me si le SMS √©choue - l'essentiel est que la commande soit cr√©√©e
    }
    
    // Vide le panier et marque comme command√©
    cart.items = [];
    cart.set("isOrdered", true);
    await cart.save();
    res.status(201).json(order);
  } catch (err) {
    res.status(500).json({ message: "Erreur serveur", error: err });
  }
};

export const getActiveOrders = async (req: Request, res: Response) => {
  const userId = req.params.userId;
  if (!userId) return res.status(400).json({ message: 'userId requis' });
  try {
    // ‚úÖ R√©cup√©rer SEULEMENT les commandes actives de l'utilisateur
    const orders = await Order.find({ userId, status: 'active' }).sort({ createdAt: -1 });
    res.json(orders);
  } catch (err) {
    console.error('[BACK] Erreur getActiveOrders:', err);
    res.status(500).json({ message: 'Erreur serveur', error: err });
  }
};

export const getAllOrdersByUser = async (req: Request, res: Response) => {
  const userId = req.params.userId;
  console.log('[BACK] getAllOrdersByUser - R√©cup√©ration de TOUTES les commandes pour:', { userId });
  if (!userId) return res.status(400).json({ message: 'userId requis' });
  try {
    // ‚úÖ R√©cup√©rer TOUTES les commandes de l'utilisateur (actives, annul√©es, termin√©es)
    const orders = await Order.find({ userId }).sort({ createdAt: -1 });
    console.log('[BACK] Toutes les commandes trouv√©es:', orders.length, 'avec statuts:', orders.map(o => o.status));
    res.json(orders);
  } catch (err) {
    console.error('[BACK] Erreur getAllOrdersByUser:', err);
    res.status(500).json({ message: 'Erreur serveur', error: err });
  }
};

export const getOrderHistory = async (req: Request, res: Response) => {
  const userId = req.params.userId;
  if (!userId) return res.status(400).json({ message: 'userId requis' });
  try {
    const orders = await Order.find({ userId, status: { $ne: 'active' } }).sort({ createdAt: -1 });
    res.json(orders);
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur', error: err });
  }
};

export const getOrdersByUser = async (req: Request, res: Response) => {
  const userId = req.params.userId;
  console.log('[BACK] getOrdersByUser', { userId });
  if (!userId) return res.status(400).json({ message: 'userId requis' });
  try {
    const orders = await Order.find({ userId }).sort({ createdAt: -1 });
    res.json(orders);
  } catch (err) {
    console.log('[BACK] Erreur getOrdersByUser:', err);
    res.status(500).json({ message: 'Erreur serveur', error: err });
  }
};

export const getAllOrders = async (req: Request, res: Response) => {
  try {
    const orders = await Order.find({}).populate('userId', 'name email phoneNumber dateOfBirth gender preferredLanguage username').sort({ createdAt: -1 });
    res.json(orders);
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur', error: err });
  }
};

export const getOrderById = async (req: Request, res: Response) => {
  const orderId = req.params.id;
  if (!orderId) return res.status(400).json({ message: 'ID de commande requis' });
  
  try {
    const order = await Order.findById(orderId).populate('userId', 'name email phoneNumber dateOfBirth gender preferredLanguage username');
    if (!order) {
      return res.status(404).json({ message: 'Commande non trouv√©e' });
    }
    res.json(order);
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur', error: err });
  }
};

export const updateOrderStatus = async (req: Request, res: Response) => {
  const orderId = req.params.id;
  const { status } = req.body;
  
  if (!orderId) return res.status(400).json({ message: 'ID de commande requis' });
  if (!status) return res.status(400).json({ message: 'Statut requis' });
  
  // Valider que le statut est valide
  const validStatuses = ['active', 'completed', 'cancelled', 'confirmed', 'rejected'];
  if (!validStatuses.includes(status)) {
    return res.status(400).json({ message: 'Statut invalide. Valeurs autoris√©es: active, completed, cancelled, confirmed, rejected' });
  }
  
  try {
    const order = await Order.findByIdAndUpdate(
      orderId,
      { status },
      { new: true }
    ).populate('userId', 'name email phoneNumber dateOfBirth gender preferredLanguage username');
    
    if (!order) {
      return res.status(404).json({ message: 'Commande non trouv√©e' });
    }
    
    res.json(order);
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur', error: err });
  }
};

// Accepter une commande (admin)
export const acceptOrder = async (req: Request, res: Response) => {
  const orderId = req.params.id;
  
  if (!orderId) return res.status(400).json({ message: 'ID de commande requis' });
  
  try {
    const order = await Order.findByIdAndUpdate(
      orderId,
      { status: 'preparing' },
      { new: true }
    ).populate('userId', 'name email phoneNumber');
    
    if (!order) {
      return res.status(404).json({ message: 'Commande non trouv√©e' });
    }
    
    // Envoyer notification au client via WebSocket
    const userId = (order.userId as any)._id.toString();
    console.log('üîç BACKEND - AcceptOrder - userId:', userId, 'orderId:', orderId);
    
    const notification = {
      title: 'Commande accept√©e',
      message: `Votre commande #${orderId.slice(-8)} a √©t√© accept√©e et est en pr√©paration`,
      type: 'order_accepted',
      orderId: orderId,
      status: 'preparing'
    };
    
    console.log('üîç BACKEND - AcceptOrder - Notification √† envoyer:', notification);
    // Envoyer √† la room de l'orderId (pas userId)
    sendOrderNotification(orderId, notification);
    
    // Envoyer aussi une notification push au mobile
    try {
      const pushNotification = {
        to: userId, // Utiliser l'userId pour la notification push
        title: 'Commande accept√©e',
        body: `Votre commande #${orderId.slice(-8)} a √©t√© accept√©e et est en pr√©paration`,
        data: {
          orderId: orderId,
          status: 'preparing',
          type: 'order_accepted'
        }
      };
      
      // Ici vous pouvez ajouter l'envoi de notification push
      console.log('üîç BACKEND - AcceptOrder - Notification push √† envoyer:', pushNotification);
    } catch (pushError) {
      console.error('‚ùå Erreur lors de l\'envoi de la notification push:', pushError);
    }

    // üÜï Envoyer SMS de confirmation d'acceptation au client
    try {
      const user = order.userId as any;
      if (user && user.phoneNumber && smsService.validatePhoneNumber(user.phoneNumber)) {
        console.log('üì± [SMS] Envoi de confirmation d\'acceptation √†:', user.phoneNumber);
        
        const formattedPhone = smsService.formatPhoneNumber(user.phoneNumber);
        const smsResult = await smsService.sendOrderNotificationSMS({
          to: formattedPhone,
          userName: user.name,
          orderId: orderId.slice(-8),
          orderTotal: order.total,
          orderStatus: 'READY',
          companyName: 'Dar-Darkom'
        });

        if (smsResult.success) {
          console.log('‚úÖ [SMS] SMS d\'acceptation envoy√© avec succ√®s');
        } else {
          console.log('‚ö†Ô∏è [SMS] √âchec d\'envoi du SMS:', smsResult.error);
        }
      } else {
        console.log('‚ö†Ô∏è [SMS] Num√©ro de t√©l√©phone invalide ou manquant pour:', user?.email);
      }
    } catch (smsError) {
      console.error('‚ùå [SMS] Erreur lors de l\'envoi du SMS d\'acceptation:', smsError);
      // On continue m√™me si le SMS √©choue
    }
    
    console.log(`‚úÖ Commande ${orderId} accept√©e par l'admin`);
    res.json({ 
      message: 'Commande accept√©e avec succ√®s',
      order: order 
    });
  } catch (err) {
    console.error('‚ùå Erreur lors de l\'acceptation de la commande:', err);
    res.status(500).json({ message: 'Erreur serveur', error: err });
  }
};

// Rejeter une commande (admin)
export const rejectOrder = async (req: Request, res: Response) => {
  const orderId = req.params.id;
  const { reason } = req.body;
  
  if (!orderId) return res.status(400).json({ message: 'ID de commande requis' });
  
  try {
    const order = await Order.findByIdAndUpdate(
      orderId,
      { status: 'rejected' },
      { new: true }
    ).populate('userId', 'name email phoneNumber');
    
    if (!order) {
      return res.status(404).json({ message: 'Commande non trouv√©e' });
    }
    
    // Envoyer notification au client via WebSocket
    const userId = (order.userId as any)._id.toString();
    console.log('üîç BACKEND - RejectOrder - userId:', userId, 'orderId:', orderId);
    sendOrderNotification(orderId, {
      title: 'Commande rejet√©e',
      message: `Votre commande #${orderId.slice(-8)} a √©t√© rejet√©e${reason ? `: ${reason}` : ''}`,
      type: 'order_rejected',
      orderId: orderId,
      status: 'rejected',
      reason: reason
    });
    
    console.log(`‚ùå Commande ${orderId} rejet√©e par l'admin`);
    res.json({ 
      message: 'Commande rejet√©e avec succ√®s',
      order: order 
    });
  } catch (err) {
    console.error('‚ùå Erreur lors du rejet de la commande:', err);
    res.status(500).json({ message: 'Erreur serveur', error: err });
  }
};

// Obtenir les commandes en attente (admin)
export const getPendingOrders = async (req: Request, res: Response) => {
  try {
    const orders = await Order.find({ status: 'active' })
      .populate('userId', 'name email phoneNumber')
      .sort({ createdAt: -1 });
    
    res.json(orders);
  } catch (err) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des commandes en attente:', err);
    res.status(500).json({ message: 'Erreur serveur', error: err });
  }
};
